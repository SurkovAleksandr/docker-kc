Заметки по курсу Docker
[код к курсу](https://github.com/karpovcourses/Docker_course.git)

# Работа с образами
docker images или docker image ls — посмотреть список образов
docker images --format '{{.Repository}}:{{.Tag}}' - информация об образах в определенном формате
docker image history --no-trunc --format '{{.CreatedBy}}' <образ> - информация о слоях образа без сокращений. Чтобы вывести другие столбцы можно использовать опции:
docker image history --no-trunc --format "table {{.ID}}\t{{.CreatedSince}}\t{{.CreatedBy}}\t{{.Size}}" <имя_образа>
  - {{.ID}} — ID слоя.
  - {{.CreatedSince}} — время создания слоя.
  - {{.CreatedBy}} — команда, которая создала слой.
  - {{.Size}} — размер слоя.

docker rmi <образ> [образ...] или docker image rm <образ> [образ...] — удалить образ(ы)

# Работа с контейнерами
docker run <образ> — поднять контейнер на основе образа \
docker run --name <имя> <образ> — при поднятии присвоить имя контейнеру \
docker run --rm <образ> — удалять контейнер после завершения его работы \
docker run -it <образ> — позволяет «войти» в контейнер во время его создания \
docker run -d <образ> — поднять контейнер в фоновом режиме \
docker run -it --entrypoint bash <образ> 
  - --entrypoint bash - указываем явно, что мы хотим запустить при старте контейнера
  - --env-file <путь_к_файлу> - указываем файл с переменными окружения в формате <ключ>=<значение>. Каждая запись с новой строки

docker ps — список активных (работающих) контейнеров \
docker ps -a — список всех контейнеров(если добавить опцию q, то выведутся тоько id контейнеров) \

docker stop <контейнер> [контейнер...] — остановить работающий(ие) контейнер(ы) \

docker start <контейнер> [контейнер...] — запустить остановленный(ые) контейнер(ы) \

docker rm <контейнер> [контейнер...] — удалить контейнер(ы) \

docker exec <контейнер> команда — запустить команду в работающем контейнер \
docker exec -it <контейнер> bash — запустить bash процесс и «войти» в контейнер \

docker build -t <имя_образа> -f <название_dockerfile> <путь_к_папке_с_dockerfile> - создание образа \
  -t - задание имени и тега образа \
  -f - название файла(вместо Dockerfile) описывающего сборку образа \

docker volumes ls — список всех volume \
docker volume create <имя> — создать volume \
docker volume rm <имя> [имя...] — удалить volume \
docker volume inspect <имя> [имя...] — информация о volume \
docker volume prune — удалить все неиспользуемые volume \
docker run -v todo_volume:/app/todo_result:ro todo_result - подключение volume к контейнеру. \
       Если подключаем bind mount, то путь должен быть абсолютным(можно использовать $(pwd)).
       Последняя опция ro позволяет ограничить доступ пользователю root в контейнере к монтируемуму файлу. \
  > [!NOTE] \
  > Когда запускается контейнер, то пользователь в контейнере root. Если используется bind mount и монтируется папка(файл), 
  > то даже если на хосте у пользователя нет прав на изменение файла пользователю(root) в контейнере будут доступны любые действия с этой папкой(файлом).

  > [!NOTE] \
  > Еще один вариант ограничить доступ к файлам из контейнера это указывать пользователя, который будет в контейнере
  > через опцию --user <id_пользователя>

## Оптимизация сборки образа  
  > [!NOTE]
  > Docker кэширует слои. Даже если написать \
  > `RUN apt update && apt install -y vim wget curl` \
  > этот слой будет закэширован. В логах будет \
  > ` => CACHED [4/4] RUN apt update && apt install -y vim wget curl` \
  > Чтобы кэширования не было надо добавить опцию --no-cache \
  > `docker build --no-cache -t <имя_образа> -f <название_dockerfile> <путь_к_папке_с_dockerfile>` \
  > или использовать --no-cache-filter
   
  > Слои, вероятность изменения которых меньше, должны идти раньше. Это связано с тем,
  > что если слой изменится, то будут пересчитаны последующие слои.
  
  > Чтобы уменьшить контекст сборки надо использовать файл .dockerignore 

  > Использовать slim или alpine пакеты
 
  > Очищать кэш apt: `rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*`

# Другие полезные команды
- docker stop $(docker ps -aq) - остановить все контейнеры
- docker system df - информация о размерах образов, контейнеров, кэша
- docker cp ./todo_result/todo_list.csv <контейнер>:/app/todo_result/todo_list.csv - копирование файла в уже запущенный контейнер
- ctrl + P  +  ctrl + Q - выход из контейнера 
- grep 
  - -v server - отфильтровать все строчки, у которых **нет** слова server
  - -i server - отфильтровать все строчки без учета регистра: server, SERVER
- https://github.com/deluan/zsh-in-docker - запуск zsh [в контейнере](https://lab.karpov.courses/learning/102/module/1276/lesson/12127/35057/233625/)

# Dockerfile
- EXEC
- ENTRYPOINT - выполнение команды. Если при запуске контейнера передать параметры, то они запишутся после значения ENTRYPOINT 
- CMD - выполнение команды. Если при запуске контейнера передать параметры, то они перезапишут значения CMD
  - [Разница в использовании ENTRYPOINT и CMD](https://lab.karpov.courses/learning/102/module/1276/lesson/12127/35057/181218/)

- COPY - копирование файлов
- ADD - тоже позволяет копировать файлы, как и COPY, но так же позволяет скачивать файлы по http ссылке.
  Распаковывает архивы при копировании.
- RUN
  - RUN apt update && apt install -y vim wget curl \
    -y - автоматически подтверждать действие(вибирать yes). Если не ставить эту опцию, то будет ошибка: \
    `ERROR: failed to solve: process "/bin/sh -c apt update && apt install vim wget curl" did not complete successfully: exit code: 1` \
- HEALTHCHECK
- EXPOSE - указывает порт, который будет открыт в контейнере


## Рекомендации по сборки образов
- использовать файл .dockerignore, чтобы в контекст не попадали лишние файлы. Это уменьшит контекст и ускорит сборку.
- уменьшать количество слоев используя && и \

## Просмотр логов контейнеров
> [!NOTE]
> Надо иметь ввиду, что логи могут выводиться программой в контейнере в stderr и если попробовать использовать grep или head \
> `docker logs <контейнер> | grep ERROR`, \
> то это ничего не даст. 
> Чтобы обойти это можно перенаправить stderr в stdout: \
> `docker logs <контейнер> 2>&1 | grep ERROR`
> НО надо помнить, что выводы в stdout и stderr будут склеиваться: сначала выведится все что было в stderr, потом все что было в stdout.
> 
> Еще один вариант решения можно найти в образе nginx - они делают ссылку на потоки: \
> `# forward request and error logs to docker log collector` \
> `   && ln -sf /dev/stdout /var/log/nginx/access.log ` \
> `   && ln -sf /dev/stderr /var/log/nginx/error.log `

- docker logs <контейнер> - выводит логи контейнера если логи пишутся в потоки вывода. Если в файл, то надо смотреть файл с логами.
  - -f <контейнер> — не отключаемся от контейнера
  - -t <контейнер> — добавляем время к логам
- docker inspect --format "{{.LogPath}}" <контейнер> - выводит путь к логам контейнера в виде json, даже если он остановлен
- docker inspect --format '{{json .Mounts}}' <контейнер> - вывод информации о примонтированных директориях. Опция json позволяет выводить информацию в виде json.

## Сеть
> [!NOTE]
> В сети по умолчанию bridge контейнеры не могут общаться между собой по названию контейнеров.
> Можно создать новую сеть с типом bridge и присоединить к ней уже существующие нужные контейнеры.
> Получится, что контейнеры будут в двух сетях.

- none: Полная изоляция от других сетей. Даже если пробрасывать порт это ни к чему не приведет - портов не будет. 
  Можно использовать например для проверки заданий студентов, чтобы исключить вызов сторонних сервисов.
- host: Противоположность сети none. Даже если не указывать порты, то все равно можно вызвать приложение через curl.
- Чтобы найти соответствие сетевому интерфейсу veth на хосте и eth в контейнере надо сделать:
  - в контейнере `cat /sys/class/net/eth0/iflink`. Где eth0 это сетевой интерфейс.
  - полученное число(допустим 53) использовать на хосте в команде `ip ad | grep 53`
- `netstat -tuplen` - информация о портах
  - -t — только TCP-соединения
  - -u — только UDP-соединения
  - -l — только слушающие (listening) сокеты
  - -p — показывает PID/имя процесса
  - -e — расширенная информация
  - -n — числовой вывод адресов и портов
- `sudo lsof -i :8080` - информация о процессах, которые слушают порт 8080
- `tcpdump -i wlp0s20f3 icmp` - проверка сетевого трафика(пакетов icmp) на интерфейсе(-i) wlp0s20f3
- `traceroute -I mail.ru` - отслеживает через какие IP адреса проходит запрос. Опция -I нужна чтобы использовались пакеты ICMP(пропускаются роутерами), а не UDP.
- `sudo iptables -t filter -vL` - вывод информации о правилах iptables.
- `docker network inspect --format '{{range $k, $v := .Containers}}{{$v.Name}}: {{$v.IPv4Address}}{{println}}{{end}}' bridge <название_сети>| sed '${/^$/d}'`
   Вывод информации о контейнерах в сети bridge и их IP адресах. Результат будет примерно таким:
   ```shell
  postgres17_5: 172.17.0.3/16
  kc_5.2: 172.17.0.5/16
  confident_driscoll: 172.17.0.2/16
  postgres_18b1: 172.17.0.4/16
  ```
  sed используется для удаления пустой строки в конце вывода.
- посмотреть все контейнеры и их сети `docker ps --format '{{.ID}} {{.Names}} {{json .Networks}}'`

- Для диагностики подключения к Kafka
  - настройки в docker-compose:
    ```shell
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      # Настройки для вызовов внутри контейнеров и с хоста
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
      KAFKA_LISTENERS: INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka:9092,EXTERNAL://localhost:9093
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    ```
  - проверка соединения с Kafka `./kafka-topics.sh --list --bootstrap-server localhost:9092`  
  - На хосте выполните netstat -an | grep 9092 или ss -lnt | grep 9092, чтобы убедиться, что локальный порт 9092 открыт.
  - Попробуйте telnet localhost 9092 или nc -vz localhost 9092 — если соединение установится, порт открыт.


## Интересные задания
- поиск логина и пароля - [5 задание 2](https://lab.karpov.courses/learning/102/module/1276/lesson/12129/35062/181449/)
- Пример того, что вывод в stderr и stdout происходит раздельно(Читать комментарии к пункту Просмотр логов контейнеров).
  - [5 задание 4](https://lab.karpov.courses/learning/102/module/1276/lesson/12129/35062/181451/)
  - [5 задание 6](https://lab.karpov.courses/learning/102/module/1276/lesson/12129/35062/181453/)
- поиск порта, которое слушает приложение(netstat -tuplen) [5 задание 9](https://lab.karpov.courses/learning/102/module/1276/lesson/12129/35062/181456/)
- изучение работы сети с типом none и host [6 урок 5](https://lab.karpov.courses/learning/102/module/1276/lesson/12130/35063/233634/)
- изучение работы сети с типом bridge [6 урок 6](https://lab.karpov.courses/learning/102/module/1276/lesson/12130/35063/233635/)
- Если у компьютера есть ethernet и wi-fi, то каждому из них выдастся свой IP-адрес и все устройства в этой сети могут обращаться к приложениям 
  на компьютере по двум IP-адресам. [урок 6 задание 3](https://lab.karpov.courses/learning/102/module/1276/lesson/12130/35064/181460/)
  
